<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed VR 360 Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; pointer-events: none; }
    </style>
</head>
<body>

    <div id="loading">Loading Images...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- CONFIGURATION ---
        // Ensure these URLs are correct and allow CORS
        const IMAGES = [
            'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Near%20Lift.jpg',
            'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Entrance.jpg',
             // Use 4K images for better performance/clarity on Quest
            'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Near%20Cafteria.jpg'
        ];
        
        const FADE_DURATION = 1.5; 

        let camera, scene, renderer;
        let meshCurrent, meshNext;
        let currentImageIndex = 0;
        let isTransitioning = false;
        let transitionTime = 0;

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);

            // --- RENDERER SETUP ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // Enable WebXR
            container.appendChild(renderer.domElement);

            document.body.appendChild(VRButton.createButton(renderer));

            // --- GEOMETRY SETUP ---
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1); // Flip geometry inside out

            // --- FIXED MATERIAL ---
            // Removed 'side: THREE.BackSide' to fix the invisibility issue
            const createMat = () => new THREE.MeshBasicMaterial({ 
                transparent: true, 
                opacity: 0,
                depthWrite: false // Prevents transparency rendering artifacts
            });

            meshCurrent = new THREE.Mesh(geometry, createMat());
            meshNext = new THREE.Mesh(geometry, createMat());

            // Render order ensures correct transparency layering
            meshCurrent.renderOrder = 1; 
            meshNext.renderOrder = 0;

            scene.add(meshCurrent);
            scene.add(meshNext);

            // --- LOAD FIRST IMAGE ---
            // We use a LoadingManager to debug if textures fail
            const manager = new THREE.LoadingManager();
            manager.onLoad = function ( ) {
                document.getElementById('loading').style.display = 'none';
                console.log( 'Loading complete!');
            };
            manager.onError = function ( url ) {
                document.getElementById('loading').innerText = 'Error loading ' + url;
                console.log( 'There was an error loading ' + url );
            };

            const loader = new THREE.TextureLoader(manager);
            
            // Load first image immediately
            loader.load(IMAGES[0], (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                meshCurrent.material.map = texture;
                meshCurrent.material.opacity = 1;
                meshCurrent.material.needsUpdate = true;
            });

            // --- INPUTS ---
            window.addEventListener('resize', onWindowResize);
            
            // Controller triggers
            const controller1 = renderer.xr.getController(0);
            controller1.addEventListener('select', nextImage);
            scene.add(controller1);

            const controller2 = renderer.xr.getController(1);
            controller2.addEventListener('select', nextImage);
            scene.add(controller2);
            
            // Desktop Click
            window.addEventListener('click', nextImage);
        }

        function nextImage() {
            if (isTransitioning) return; 

            // Calculate next index
            let nextIndex = (currentImageIndex + 1) % IMAGES.length;
            console.log("Loading image index:", nextIndex);

            // Load texture for the NEXT sphere
            new THREE.TextureLoader().load(IMAGES[nextIndex], (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                
                meshNext.material.map = texture;
                meshNext.material.opacity = 0;
                meshNext.material.needsUpdate = true;
                meshNext.visible = true; // Make sure it's enabled

                // Start animation
                isTransitioning = true;
                transitionTime = 0;
                currentImageIndex = nextIndex;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (isTransitioning) {
                const delta = 0.02; // Approximation for VR frame time
                transitionTime += delta;
                let progress = transitionTime / FADE_DURATION;
                
                if (progress >= 1) {
                    progress = 1;
                    isTransitioning = false;
                    
                    // SWAP: Current becomes Next (for next time)
                    const temp = meshCurrent;
                    meshCurrent = meshNext;
                    meshNext = temp;
                    
                    meshCurrent.renderOrder = 1;
                    meshNext.renderOrder = 0;
                }

                // Cross-fade opacity
                if (meshCurrent.material.map) meshCurrent.material.opacity = 1 - progress;
                if (meshNext.material.map) meshNext.material.opacity = progress;
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
