<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Res VR Gallery</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- CONFIGURATION ---
        const IMAGES = [
            // Image 1
            'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Near%20Lift.jpg',
            // Image 2 (Different scene)
            'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Entrance.jpg',
            // Image 3
            'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Near%20Cafteria.jpg'
        ];
        
        const FADE_DURATION = 2.0; // Seconds for transition to take

        // --- VARIABLES ---
        let camera, scene, renderer;
        let sphereGroup;
        let meshCurrent, meshNext;
        let currentImageIndex = 0;
        
        // Transition State
        let isTransitioning = false;
        let transitionTime = 0;

        init();
        animate();

        function init() {
            // 1. Setup Scene
            const container = document.createElement('div');
            document.body.appendChild(container);
            scene = new THREE.Scene();

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);

            // 3. Renderer (High Quality Settings)
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio); // CRITICAL for clarity
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            // Improve color accuracy
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            container.appendChild(renderer.domElement);

            document.body.appendChild(VRButton.createButton(renderer));

            // 4. Create the Two Spheres for Cross-Fading
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1); // Invert for inside view

            // Helper to create materials with correct settings
            const createMat = () => new THREE.MeshBasicMaterial({ 
                transparent: true, 
                opacity: 0,
                side: THREE.BackSide // Render on inside
            });

            meshCurrent = new THREE.Mesh(geometry, createMat());
            meshNext = new THREE.Mesh(geometry, createMat());

            // Ensure render order so transparency works correctly
            meshCurrent.renderOrder = 1;
            meshNext.renderOrder = 0;

            scene.add(meshCurrent);
            scene.add(meshNext);

            // 5. Load Initial Image
            loadTexture(IMAGES[0], meshCurrent, true);

            // 6. Inputs (Controller Trigger or Click)
            window.addEventListener('resize', onWindowResize);
            
            // Add listener to WebXR Controller 1 and 2
            const controller1 = renderer.xr.getController(0);
            controller1.addEventListener('select', nextImage);
            scene.add(controller1);

            const controller2 = renderer.xr.getController(1);
            controller2.addEventListener('select', nextImage);
            scene.add(controller2);
            
            // Mouse click for desktop testing
            window.addEventListener('click', nextImage);
        }

        function loadTexture(url, mesh, showImmediately = false) {
            const loader = new THREE.TextureLoader();
            loader.load(url, (texture) => {
                // CLARITY FIX: Maximize Anisotropy
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.colorSpace = THREE.SRGBColorSpace;
                
                // Apply texture
                mesh.material.map = texture;
                mesh.material.needsUpdate = true;

                if (showImmediately) {
                    mesh.material.opacity = 1;
                }
            });
        }

        function nextImage() {
            if (isTransitioning) return; // Prevent double clicking

            // 1. Calculate next index
            let nextIndex = (currentImageIndex + 1) % IMAGES.length;
            
            // 2. Load next image onto the hidden sphere (meshNext)
            // Reset opacity just in case
            meshNext.material.opacity = 0; 
            loadTexture(IMAGES[nextIndex], meshNext, false);

            // 3. Start Transition
            isTransitioning = true;
            transitionTime = 0;
            
            // Update index tracking
            currentImageIndex = nextIndex;
            
            console.log("Transitioning to image:", nextIndex);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(time, frame) {
            // Handle Cross-Fade Logic
            if (isTransitioning) {
                const delta = 0.016; // Approx 60fps frame time
                transitionTime += delta;
                
                // Calculate progress (0 to 1)
                let progress = transitionTime / FADE_DURATION;
                
                if (progress >= 1) {
                    progress = 1;
                    isTransitioning = false;
                    
                    // Swap the meshes internally so we are ready for next time
                    // The "Next" became the "Current"
                    const tempMesh = meshCurrent;
                    meshCurrent = meshNext;
                    meshNext = tempMesh;
                    
                    // Ensure final states
                    meshCurrent.material.opacity = 1;
                    meshNext.material.opacity = 0;
                    
                    // Optimization: Don't render the hidden one
                    meshNext.visible = false; 
                } else {
                    // Ease-in-out calculation for smoothness
                    // Simple linear:
                    meshNext.visible = true;
                    meshCurrent.material.opacity = 1 - progress;
                    meshNext.material.opacity = progress;
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
