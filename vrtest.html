<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Tour with Gaze Hotspots</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; font-size: 24px; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;
        }
        #hotspot-info {
            position: absolute; 
            bottom: 20px; left: 50%; 
            transform: translateX(-50%); 
            color: white; 
            font-size: 18px; 
            padding: 10px 20px; 
            background: rgba(49, 130, 206, 0.8); /* Tailwind blue-600 with transparency */
            border-radius: 8px;
            pointer-events: none; /* Crucial: ensures VR controls still work */
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0;
            z-index: 10;
        }
        #instructions {
            position: absolute; 
            top: 10px; right: 10px;
            color: #ccc;
            font-size: 14px;
            background: rgba(0,0,0,0.4);
            padding: 8px;
            border-radius: 6px;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading">Loading Experience...</div>
    <div id="hotspot-info"></div>
    <!-- New UI instruction for coordinate finding -->
    <div id="instructions">
        Hint: Look at a position and press **'P'** to log coordinates to console.
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        // Import OrbitControls for desktop mouse rotation
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        // 1. Define your scenes
        const SCENES = [
            {
                id: 0,
                image: 'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Near%20Lift.jpg',
                // Hotspots for this scene
                hotspots: [
                    { lat: 0, lon: 0, targetScene: 1, text: "Go to Stonehenge" }, // Front
                    { lat: 0, lon: 180, targetScene: 2, text: "Go to Sao Paulo" } // Behind
                ]
            },
            {
                id: 1,
                image: 'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Entrance.jpg',
                hotspots: [
                    { lat: 0, lon: -90, targetScene: 0, text: "Back to Temple" } // Left
                ]
            },
            {
                id: 2,
                image: 'https://ggzftdlppjdrqugcrhgz.supabase.co/storage/v1/object/public/vr/images/Near%20Cafteria.jpg',
                hotspots: [
                    // This is the hotspot you asked about, now with the descriptive text used.
                    { lat: 10, lon: 45, targetScene: 0, text: "Return to the Roman Temple" }
                ]
            }
        ];

        // --- VARIABLES ---
        let camera, scene, renderer;
        let controls; // Variable for OrbitControls
        let sphereMesh, sphereMeshNext; // Two spheres for transition
        let activeHotspots = []; // Stores current button meshes
        let raycaster, reticle;
        
        // UI element reference
        const infoDiv = document.getElementById('hotspot-info');
        
        // Gaze Logic variables
        let intersectedObject = null;
        let gazeStartTime = 0;
        const GAZE_DELAY = 1500; // 1.5 Seconds to trigger
        const GAZE_COLOR_IDLE = 0xffffff;
        const GAZE_COLOR_HOVER = 0x00ff00;

        // Transition variables
        let currentSceneIndex = 0;
        let isTransitioning = false;
        let transitionTime = 0;
        const FADE_DURATION = 1.5;

        init();
        animate();
        setupCoordinateLogging();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            // 1. Scene & Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // 3. Desktop Controls (OrbitControls)
            controls = new OrbitControls(camera, renderer.domElement);
            // Disable moving or zooming, only allow rotation (360 view)
            controls.enableZoom = false;
            controls.enablePan = false;
            controls.rotateSpeed = -0.5; // Invert to feel more like a mouse drag/swipe

            // 4. The 360 Spheres (Double buffering for cross-fade)
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1); // Invert
            
            // Create two meshes for fading
            sphereMesh = new THREE.Mesh(geometry, createMaterial(0));
            sphereMeshNext = new THREE.Mesh(geometry, createMaterial(0));
            sphereMesh.renderOrder = 1;
            sphereMeshNext.renderOrder = 0; // Behind
            
            scene.add(sphereMesh);
            scene.add(sphereMeshNext);

            // 5. Reticle (The Cursor)
            // We attach this to the CAMERA so it stays in center of vision
            const reticleGeo = new THREE.RingGeometry(0.02, 0.04, 32);
            const reticleMat = new THREE.MeshBasicMaterial({ 
                color: GAZE_COLOR_IDLE, 
                depthTest: false, // Always show on top
                transparent: true
            });
            reticle = new THREE.Mesh(reticleGeo, reticleMat);
            reticle.position.z = -1; // 1 meter in front of face
            reticle.renderOrder = 999; // Draw last
            camera.add(reticle);
            scene.add(camera); // Important: Add camera to scene

            // 6. Raycaster
            raycaster = new THREE.Raycaster();

            // 7. Initial Load
            loadScene(0);

            window.addEventListener('resize', onWindowResize);
        }

        function createMaterial(opacity) {
            return new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: opacity,
                depthWrite: false, // Fix black screen issues
                side: THREE.FrontSide // Standard rendering
            });
        }

        // --- COORDINATE LOGGING FUNCTION ---
        function getGazeCoordinates() {
            if (!camera) return { lat: 0, lon: 0 };

            const vector = new THREE.Vector3();
            const spherical = new THREE.Spherical();
            
            // 1. Get the camera's forward direction vector (in world space)
            camera.getWorldDirection(vector);
            
            // 2. Since the panorama sphere is inverted (geometry.scale(-1, 1, 1)), 
            // the point we are looking at *inside* the sphere is in the opposite direction.
            // We look along the vector multiplied by -1.
            vector.multiplyScalar(-1);
            
            // 3. Convert the vector to standard spherical coordinates (r, phi, theta)
            spherical.setFromVector3(vector);
            
            // 4. Convert to Hotspot Lat/Lon convention:
            
            // Latitude: 90 deg (up) - phi (where phi is 0 up, 180 down)
            const lat = 90 - THREE.MathUtils.radToDeg(spherical.phi);

            // Longitude: theta (normalized to [-180, 180])
            let lon = THREE.MathUtils.radToDeg(spherical.theta);

            // Normalize theta (lon) from [0, 360] to [-180, 180] if necessary
            if (lon > 180) {
                lon -= 360;
            }

            return { lat: lat.toFixed(2), lon: lon.toFixed(2) };
        }

        // --- KEYBOARD LISTENER FOR LOGGING COORDINATES ---
        function setupCoordinateLogging() {
            document.addEventListener('keydown', (event) => {
                // Check if 'P' key (case insensitive) is pressed
                if (event.key.toUpperCase() === 'P') {
                    if (camera) {
                        const coords = getGazeCoordinates();
                        console.log(`--- NEW HOTSPOT COORDINATES ---`);
                        console.log(`Current Scene ID: ${SCENES[currentSceneIndex].id}`);
                        console.log(`{ lat: ${coords.lat}, lon: ${coords.lon}, targetScene: [ID], text: "New Hotspot Name" }`);
                        console.log(`-------------------------------`);
                        
                        // Optional: Flash the info box for immediate feedback
                        updateInfo(`Coordinates logged to console: Lat ${coords.lat}, Lon ${coords.lon}`, true);
                        setTimeout(() => updateInfo("", false), 2000);
                        
                    } else {
                        console.error("Camera not initialized yet.");
                    }
                }
            });
        }
        // --- CORE LOGIC: Positioning Hotspots ---
        function loadScene(index) {
            // Load Texture
            const loader = new THREE.TextureLoader();
            loader.load(SCENES[index].image, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                
                // If this is the very first load
                if (!sphereMesh.material.map) {
                    sphereMesh.material.map = texture;
                    sphereMesh.material.opacity = 1;
                    sphereMesh.material.needsUpdate = true;
                    document.getElementById('loading').style.display = 'none';
                    createHotspotsForScene(index);
                } else {
                    // It's a transition
                    startTransition(texture, index);
                }
            });
        }

        function createHotspotsForScene(index) {
            // 1. Clear old hotspots
            activeHotspots.forEach(mesh => scene.remove(mesh));
            activeHotspots = [];

            // 2. Create new ones
            const data = SCENES[index].hotspots;
            if(!data) return;

            data.forEach(hotspotData => {
                // Create a simple circular button
                const geo = new THREE.CircleGeometry(15, 32);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);

                // --- MAGIC MATH: Lat/Lon to 3D XYZ ---
                // phi = 90 - lat (vertical)
                // theta = lon (horizontal)
                const lat = hotspotData.lat;
                const lon = hotspotData.lon;
                const radius = 450; // Slightly inside the 500 sphere

                const phi = THREE.MathUtils.degToRad(90 - lat);
                const theta = THREE.MathUtils.degToRad(lon);

                mesh.position.setFromSphericalCoords(radius, phi, theta);
                mesh.lookAt(0, 0, 0); // Face the user

                // Attach data to mesh for Raycaster
                mesh.userData = { 
                    targetScene: hotspotData.targetScene,
                    text: hotspotData.text // Store the description text
                };
                
                scene.add(mesh);
                activeHotspots.push(mesh);
            });
        }

        function startTransition(newTexture, nextIndex) {
            if (isTransitioning) return;

            // Prepare "Next" sphere
            sphereMeshNext.material.map = newTexture;
            sphereMeshNext.material.opacity = 0;
            sphereMeshNext.visible = true;
            
            // Hide hotspots and info during transition
            activeHotspots.forEach(h => h.visible = false);
            infoDiv.style.opacity = 0;

            isTransitioning = true;
            transitionTime = 0;
            
            // Callback to create new hotspots AFTER fade finishes
            setTimeout(() => {
                currentSceneIndex = nextIndex;
                createHotspotsForScene(nextIndex);
            }, FADE_DURATION * 1000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }
        
        // Function to update the 2D info box
        function updateInfo(text, show) {
            if (show && text) {
                infoDiv.textContent = text;
                infoDiv.style.opacity = 1;
            } else {
                infoDiv.style.opacity = 0;
            }
        }

        function render() {
            const dt = 0.016;
            
            // Update OrbitControls for desktop rotation
            if (controls) {
                controls.update();
            }

            // --- 1. TRANSITION LOGIC ---
            if (isTransitioning) {
                transitionTime += dt;
                let progress = transitionTime / FADE_DURATION;
                if (progress > 1) progress = 1;

                sphereMesh.material.opacity = 1 - progress;
                sphereMeshNext.material.opacity = progress;

                if (progress === 1) {
                    isTransitioning = false;
                    // Swap
                    let temp = sphereMesh;
                    sphereMesh = sphereMeshNext;
                    sphereMeshNext = temp;
                    sphereMesh.renderOrder = 1;
                    sphereMeshNext.renderOrder = 0;
                }
            }

            // --- 2. GAZE LOGIC ---
            // Only update gaze if we aren't transitioning
            if (!isTransitioning) {
                // A. Cast Ray from Camera Center
                // We only do gaze interaction (hotspot activation) if the user is not actively rotating the view (using OrbitControls)
                // or if they are in an XR session.
                const isInteracting = controls && controls.isDragging;
                const isXRSession = renderer.xr.isPresenting;
                
                if (!isInteracting || isXRSession) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(activeHotspots);

                    if (intersects.length > 0) {
                        // HIT!
                        const object = intersects[0].object;
                        
                        if (intersectedObject !== object) {
                            // New Hover
                            if (intersectedObject) {
                                intersectedObject.scale.set(1, 1, 1);
                            }
                            intersectedObject = object;
                            gazeStartTime = Date.now();
                            reticle.material.color.setHex(GAZE_COLOR_HOVER);
                            // Show info text immediately
                            updateInfo(object.userData.text, true); 
                            // Optional: Scale button up
                            object.scale.set(1.2, 1.2, 1.2);
                        } else {
                            // Still Hovering - Check Timer
                            const elapsed = Date.now() - gazeStartTime;
                            
                            // Animate Reticle (Scale down to indicate loading)
                            const scale = 1 - (elapsed / GAZE_DELAY);
                            reticle.scale.setScalar(scale > 0 ? scale : 0);

                            if (elapsed >= GAZE_DELAY) {
                                // TRIGGER!
                                const target = object.userData.targetScene;
                                console.log("Teleporting to scene", target);
                                
                                // Reset reticle and info
                                reticle.scale.setScalar(1);
                                reticle.material.color.setHex(GAZE_COLOR_IDLE);
                                updateInfo("", false); // Hide info after trigger
                                intersectedObject.scale.set(1, 1, 1);
                                intersectedObject = null; // Prevent double trigger
                                
                                loadScene(target);
                            }
                        }

                    } else {
                        // NO HIT
                        if (intersectedObject) {
                            // Reset previous object scale and info
                            intersectedObject.scale.set(1, 1, 1);
                            updateInfo("", false); // Hide info
                        }
                        intersectedObject = null;
                        reticle.material.color.setHex(GAZE_COLOR_IDLE);
                        reticle.scale.setScalar(1);
                    }
                } else {
                     // If interacting with controls, suppress gaze interaction
                    if (intersectedObject) {
                        intersectedObject.scale.set(1, 1, 1);
                    }
                    intersectedObject = null;
                    reticle.material.color.setHex(GAZE_COLOR_IDLE);
                    reticle.scale.setScalar(1);
                    updateInfo("", false);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
